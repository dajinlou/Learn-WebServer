---------------1.0------------------------------

1. 忽略管道信号有什么用？
     这段代码的目的是忽略SIGPIPE信号。当某个进程向一个没有读取端的管端（pipe）写入
数据时，通常会收到SIGPIPE信号。默认情况下，这个信号会终止进程，但这个函数的
函数体通过将其处理方式设置为忽略，使得进程在发生这种情况时不会终止。

2. 如何具体处理超时定时器？
    通过使用小根堆数据结构，每次推出已过期的定时器，


3. 超时之后，只是简单的移除定时器吗？还做哪些工作？
    我们知道TinyWebServer是基于升序链表定时器结构，超时之后，1）删除定时器 2）将当前文件描述符从树上摘下

4. RequestData和MyTimer的关系是你中有我，我中有你？？？
    它没有调用MyTimer中的Update更新过期事件，而是通过先分离定时器，让分离后的定时器自动过期，然后在处理请求中添加新的定时器

    经过我研究发现，当分离后，会为请求添加新的定时器，并加入队列中，这个定时器中保存有RequestData指针，一旦定时器释放，就会
调用RequestData释放内存，一旦RequestData释放内存，在RequestData析构函数中，会close(fd)。

5. 定时器过期，仅仅是出队这个操作吗？
    具体看回答4

6. 我发现RequestData中为什么要有MyTimer对象，有什么用呢？
    用于控制小根堆保存的定时器，小根堆添加的定时器和RequestData中的定时器对象是同一个定时器对象，所以RequestData保存一份，用于
更新优先队列中定时器的过期时间。

7. 线程池的使用
    线程池和任务队列写一起了，任务队列存储的是RequestData, 线程池中线程池执行的任务是MyHandler函数.




    

------------------------2.0--------------------------------------------

8. 线程池销毁有问题，线程是不是并不能完全销毁?
    回复：可以销毁，不知道为什么会多显示一个线程，当线程池关闭时，显示进程中还有2个线程
    ps -aux | grep server 查看进程编号
    ps -T -p PID  查看当前进程有几个线程






------------------4.0 ----------------------------

9. 关于互斥锁类，成员变量使用[引用]声明的原因
    每个 MutexLockGuard 对象都有自己的 MutexLock 实例。如果需要多个 MutexLockGuard 实例共享同一个 MutexLock 对象，那么使用引用类型是合适的。

10. 它是怎么保证多个对象访问同一个对象的。换句话说，它是怎么实现单例模式的？
    它使用static关键字，仅实例化一次。

11. 4.0版本的大致逻辑是：
    1) Epoll类是核心，负责分发事件（包括连接和读事件）、维护定时器队列，以及{文件描述符,请求}不需要频频new和delete请求对象
                                     CONNECT
    客户端发起请求------->Epoll收到——————————————>建立连接、创建请求对象、添加红黑树上、同时建立定时器，并将其添加到优先队列中
                                |
                                |EPOLLIN
                                v 
                                将请求中绑定的定时器删除，后面会添加新的（分离定时器）、将请求添加到线程池中、线程池将其放入任务队列并发送通知信号、任务线程收到线程后取出任务并执行





-------------------------------5.0------------------------------------

12. 它是怎么由读事件向写事件转换的？在RequestData中哪里有体现？
     它使用handleRead()处理完客户端请求后，将文件描述符通过handleConn函数置为EPOLLOUT,并修改红黑树集合中的文件描述符感兴趣的事件。
     EPOLLOUT事件：
     EPOLLOUT事件只有在连接时触发一次，表示可写，其他时候想要触发，那要先准备好下面条件：
     1.某次write，写满了发送缓冲区，返回错误码为EAGAIN。
     2.对端读取了一些数据，又重新可写了，此时会触发EPOLLOUT。
     简单地说：EPOLLOUT事件只有在不可写到可写的转变时刻，才会触发一次，所以叫边缘触发，这叫法没错的！
     其实，如果真的想强制触发一次，也是有办法的，直接调用epoll_ctl重新设置一下event就可以了，event跟原来的设置一模一样都行（但必须包含EPOLLOUT），关键是重新设置，就会马上触发一次EPOLLOUT事件。
     1. 缓冲区由满变空.
     2.同时注册EPOLLIN | EPOLLOUT事件，也会触发一次EPOLLOUT事件
     这个两个也会触发EPOLLOUT事件
     https://www.cnblogs.com/zl-graduate/articles/6724446.html


13. 文件描述符对应的HTTP请求，什么时候释放呢？
    定时器被释放时，对应的HTTP请求会被释放，因为HTTP是它的成员变量。同时在定时器析构函数中调用epoll_del删除描述符，同时将文件描述符集合重置。（Epoll::epoll_del()）

14. 5.0版本的大致逻辑是：
                                                    ------------------------>1) 建立连接
                                                   |
    客户端发起请求 ----->epoll_wait返回------->getEventsRequest分发事件 ------>2) 将其添加到线程池(响应请求/处理请求(/hello.html)  |
                                                   |      epoll_mod触发写请求          ^                                         |
                                                   |                                  |                                         |
                                                    ----------------------------------                                          |
                                                                                                                 EPOLLIN        |       EPOLLOUT                   
                                                                                                                      -------------------------
                                                                                                                     |                         |
                                                                                                                     |                         |
                                                                                                                     V                         V                            
                                                                                                                handleRead()                handleWrite()
                                                                                                   (处理客户端的同时，将响应数据也准备好)  (向客户端发送响应数据)

    注意：
     1) 当建立连接时，为其文件描述符绑定一个HTTP请求，同时将其HTTP请求添加到定时器。通过定时器Manager添加到小根堆中。
     2) 当处理读或写事件时，将文件描述符对应的HTTP请求中的定时器分离，并将其对应的读写标志置位TRUE。
     3) 当处理http请求时，分析完请求并准备好响应数据后，通过handleConn函数，将HTTP请求中的定时器更新，并将文件描述符感兴趣的事件设置成EPOLLOUT,并修改树上的文件描述符
     4) 当响应http请求时，通过handleConn函数，将HTTP请求中的定时器更新，并将文件描述符感兴趣的事件设置成EPOLLIN,并修改树上的文件描述符














存在问题：
（1）定时器存在问题，当接收客户端的请求时，它就进行请求和定时器分离，然后定时器就没再更新过，这样的话岂不是变成了先进先出了。
    已解决---》具体看回答4

（2） 线程池存在问题，有点混乱，逻辑不清晰，线程池既干任务队列的活又干线程池的活，不纯粹。
    改进地方：单独写一个任务队列对象，用于添加和删除对象；工作线程处理方式继续保留，关于处理请求放到RequestData中；还有封装的结构体
    可以使用模板代替。





拓展：
EPOLLIN: 表示有数据可读。数值通常为 0x001。
EPOLLOUT: 表示有空间可写。数值通常为 0x004。
EPOLLERR: 表示发生错误。数值通常为 0x008。
EPOLLHUP: 表示对端关闭了连接。数值通常为 0x010。
EPOLLRDHUP: 表示对端关闭了连接，并且所有数据都已读取。数值通常为 0x2000（这个值在不同的 Linux 版本中可能有所不同）。
EPOLLPRI: 表示有高优先级数据可读。数值通常为 0x002。
